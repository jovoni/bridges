max_time = 100
max_cells = 40
first_n_bfb_cycles = 0
first_round_of_bfb = TRUE
breakpoint_support = "uniform"
hotspot = as.integer(L * 0.9)
alpha_support = 3
beta_support = 3
repeat {
sim <- tryCatch({
gillespie_sim(
initial_cells = initial_cells,
initial_sequence_length = L,
birth_rate = birth_rate,
death_rate = death_rate,
bfb_prob = bfb_prob,
selection_rate = selection_rate,
max_time = max_time,
max_cells = max_cells,
first_n_bfb_cycles = first_n_bfb_cycles,
first_round_of_bfb = initial_break,
breakpoint_support = breakpoint_support,
hotspot = hotspot,
alpha = alpha_support,
beta = beta_support
)
}, error = function(e) {
print("re-doing")
NULL
})
if (!is.null(sim)) {
break
}
}
setwd("~/Github/bridges_material/MFNJ")
rm(list = ls())
require(bridges)
require(patchwork)
require(ape)
require(patchwork)
require(Quartet)
require(phangorn)
require(ggtree)
require(dplyr)
require(ggplot2)
set.seed(1234)
initial_cells = 1
L = 500
birth_rate = .5
death_rate = .1
bfb_prob = .6
selection_rate = 0
max_time = 100
max_cells = 40
first_n_bfb_cycles = 0
first_round_of_bfb = TRUE
breakpoint_support = "uniform"
hotspot = as.integer(L * 0.9)
alpha_support = 3
beta_support = 3
repeat {
sim <- tryCatch({
gillespie_sim(
initial_cells = initial_cells,
initial_sequence_length = L,
birth_rate = birth_rate,
death_rate = death_rate,
bfb_prob = bfb_prob,
selection_rate = selection_rate,
max_time = max_time,
max_cells = max_cells,
first_n_bfb_cycles = first_n_bfb_cycles,
first_round_of_bfb = first_round_of_bfb,
breakpoint_support = breakpoint_support,
hotspot = hotspot,
alpha = alpha_support,
beta = beta_support
)
}, error = function(e) {
print("re-doing")
NULL
})
if (!is.null(sim)) {
break
}
}
bridges::reconstruct_tree(sim, L, alpha = .1, cn_weight = .001, verbose = TRUE)
setwd("~/Github/bridges_material/MFNJ")
rm(list = ls())
require(bridges)
require(patchwork)
require(ape)
require(patchwork)
require(Quartet)
require(phangorn)
require(ggtree)
require(dplyr)
require(ggplot2)
set.seed(1234)
# Simulation Parameters
initial_cells = 1
L = 500
birth_rate = .5
death_rate = 0
bfb_prob = .6
selection_rate = 0
max_time = 100
max_cells = 40
first_n_bfb_cycles = 0
first_round_of_bfb = TRUE
breakpoint_support = "uniform"
hotspot = as.integer(L * 0.9)
alpha_support = 3
beta_support = 3
repeat {
sim <- tryCatch({
gillespie_sim(
initial_cells = initial_cells,
initial_sequence_length = L,
birth_rate = birth_rate,
death_rate = death_rate,
bfb_prob = bfb_prob,
selection_rate = selection_rate,
max_time = max_time,
max_cells = max_cells,
first_n_bfb_cycles = first_n_bfb_cycles,
first_round_of_bfb = first_round_of_bfb,
breakpoint_support = breakpoint_support,
hotspot = hotspot,
alpha = alpha_support,
beta = beta_support
)
}, error = function(e) {
print("re-doing")
NULL
})
if (!is.null(sim)) {
break
}
}
bridges::reconstruct_tree(sim, L, alpha = .1, cn_weight = .001, verbose = TRUE)
setwd("~/Github/bridges_material/MFNJ")
rm(list = ls())
require(bridges)
require(patchwork)
require(ape)
require(patchwork)
require(Quartet)
require(phangorn)
require(ggtree)
require(dplyr)
require(ggplot2)
set.seed(1234)
# Simulation Parameters
initial_cells = 1
L = 500
birth_rate = .5
death_rate = 0
bfb_prob = .6
selection_rate = 0
max_time = 100
max_cells = 32
first_n_bfb_cycles = 0
first_round_of_bfb = TRUE
breakpoint_support = "uniform"
hotspot = as.integer(L * 0.9)
alpha_support = 3
beta_support = 3
repeat {
sim <- tryCatch({
gillespie_sim(
initial_cells = initial_cells,
initial_sequence_length = L,
birth_rate = birth_rate,
death_rate = death_rate,
bfb_prob = bfb_prob,
selection_rate = selection_rate,
max_time = max_time,
max_cells = max_cells,
first_n_bfb_cycles = first_n_bfb_cycles,
first_round_of_bfb = first_round_of_bfb,
breakpoint_support = breakpoint_support,
hotspot = hotspot,
alpha = alpha_support,
beta = beta_support
)
}, error = function(e) {
print("re-doing")
NULL
})
if (!is.null(sim)) {
break
}
}
bridges::reconstruct_tree(sim, L, alpha = .1, cn_weight = .001, verbose = TRUE)
results = bridges::reconstruct_tree(sim, L, alpha = .1, cn_weight = .001, verbose = TRUE)
bridges::plot_tree(results$cell_df)
bridges::plot_tree(results$cell_df, use_computed_branch_lengths = F)
true_tree = bridges::plot_tree(sim$cell_lifetimes, use_computed_branch_lengths = F, full_tree = F)
true_tree = bridges::plot_tree(sim$cell_lifetimes, use_computed_branch_lengths = F, full_tree = T)
source("utils_DML.R")
# Input and initialization
cn_weight = 1e-3
alpha = .1
eps = .01
cells = sim$final_cells
setwd("~/Github/bridges_material/MFNJ/MFNJ_develop")
source("utils_DML.R")
source("utils_DML.R")
source("utils_MFNJ.R")
# Input and initialization
cn_weight = 1e-3
alpha = .1
eps = .01
cells = sim$final_cells
cells_names = sim$cell_lifetimes %>% dplyr::filter(is_alive) %>% dplyr::pull(cell_id)
original_cells = cells_names = lapply(cells_names, function(c) {paste0("|",c,"|")}) %>% unlist()
N0 = length(cells)
C = bridges:::cells2countvectors(cells, L)
rownames(C) = cells_names
# Initalize distance matrix D
D = compute_distance_matrix(C, alpha = alpha, cn_weight = cn_weight)
colnames(D) = rownames(D) = rownames(C)
# Initialize Mask matrix M
M = matrix(data = FALSE, nrow = N0, ncol = N0)
diag(M) = TRUE
colnames(M) = rownames(M) = rownames(C)
# Initialize parent-daughters list
pd_list = list()
# Init iter and convergence flag
iter = 0
found_root = FALSE
source("utils_DML.R")
source("utils_MFNJ.R")
# Input and initialization
cn_weight = 1e-3
alpha = .1
eps = .01
cells = sim$final_cells
cells_names = sim$cell_lifetimes %>% dplyr::filter(is_alive) %>% dplyr::pull(cell_id)
original_cells = cells_names = lapply(cells_names, function(c) {paste0("|",c,"|")}) %>% unlist()
N0 = length(cells)
# Initialize Cell matix C
C = bridges:::cells2countvectors(cells, L)
rownames(C) = cells_names
# Initalize distance matrix D
D = compute_distance_matrix(C, alpha = alpha, cn_weight = cn_weight)
colnames(D) = rownames(D) = rownames(C)
# Initialize Mask matrix M
M = matrix(data = FALSE, nrow = N0, ncol = N0)
diag(M) = TRUE
colnames(M) = rownames(M) = rownames(C)
# Initialize parent-daughters list
pd_list = list()
# Init iter and convergence flag
iter = 0
found_root = FALSE
while (!found_root) {
if (length(unique(rownames(C))) != nrow(C)) print(culo)
print(iter)
if ("new_cells" %in% rownames(C)) print(pippo)
# Iteration ####
# Mask Distance matrix
if (runif(1, 0, 1) < .2) {
D = compute_distance_matrix(C, alpha = alpha, cn_weight = cn_weight)
} else {
D = compute_distance_matrix(C, alpha = 0, cn_weight = cn_weight)
}
D[M] = Inf
# Find smallest distance
new_cells_and_daughters = NULL
minimal_distances = unique(sort(D))
min_dist_idx = 0
while (is.null(new_cells_and_daughters)) {
min_dist_idx = min_dist_idx + 1
min_dist = minimal_distances[min_dist_idx]
otus = propose_groups_of_cells(D, min_dist)
new_cells_and_daughters = clean_group_of_cells(otus, C)
}
new_cells = new_cells_and_daughters$parents
daughters = new_cells_and_daughters$daughters
# Update parent-daugherts list pd_list
names(daughters) = rownames(new_cells)
pd_list = c(pd_list, daughters)
# Update distance matrix
D_new <- compute_distance_matrix_enhanced(new_cells, alpha = alpha, cn_weight = cn_weight)  # Distances within Y
D_old_new <- compute_distance_matrix_enhanced(C, new_cells, alpha = alpha, cn_weight = cn_weight)  # Distances between X and Y
D <- rbind(
cbind(D, D_old_new),
cbind(t(D_old_new), D_new)
)
# Update C
C = rbind(C, new_cells)
# Update M
M = extend_M(M = M, C = C)
# Update names
rownames(M) = colnames(M) = rownames(D) = colnames(D) = rownames(C)
# Update masking of M
M = update_M(M, daughters, pd_list)
# Check if we find root, i.e. pseudo cell with all original cells
is_root = function(cell_name, N0) {
cells_used = unlist(strsplit(gsub("\\|", "", cell_name), "-"))
if (length(cells_used) != length(unique(cells_used))) stop("something bad happened")
length(cells_used) == N0
}
found_root = any(unlist(lapply(rownames(new_cells), function(x) {is_root(x, N0)})))
iter = iter + 1
}
source("utils_DML.R")
source("utils_MFNJ.R")
# Input and initialization
cn_weight = 1e-3
alpha = .1
eps = .01
cells = sim$final_cells
cells_names = sim$cell_lifetimes %>% dplyr::filter(is_alive) %>% dplyr::pull(cell_id)
original_cells = cells_names = lapply(cells_names, function(c) {paste0("|",c,"|")}) %>% unlist()
N0 = length(cells)
C = bridges:::cells2countvectors(cells, L)
rownames(C) = cells_names
# Initalize distance matrix D
D = compute_distance_matrix(C, alpha = alpha, cn_weight = cn_weight)
colnames(D) = rownames(D) = rownames(C)
# Initialize Mask matrix M
M = matrix(data = FALSE, nrow = N0, ncol = N0)
diag(M) = TRUE
colnames(M) = rownames(M) = rownames(C)
# Initialize parent-daughters list
pd_list = list()
# Init iter and convergence flag
iter = 0
found_root = FALSE
if (length(unique(rownames(C))) != nrow(C)) print(culo)
print(iter)
if ("new_cells" %in% rownames(C)) print(pippo)
# Iteration ####
# Mask Distance matrix
if (runif(1, 0, 1) < .2) {
D = compute_distance_matrix(C, alpha = alpha, cn_weight = cn_weight)
} else {
D = compute_distance_matrix(C, alpha = 0, cn_weight = cn_weight)
}
D[M] = Inf
# Find smallest distance
new_cells_and_daughters = NULL
minimal_distances = unique(sort(D))
min_dist_idx = 0
while (is.null(new_cells_and_daughters)) {
min_dist_idx = min_dist_idx + 1
min_dist = minimal_distances[min_dist_idx]
otus = propose_groups_of_cells(D, min_dist)
new_cells_and_daughters = clean_group_of_cells(otus, C)
}
min_dist_idx
min_dist = minimal_distances[min_dist_idx]
min_dist
otus = propose_groups_of_cells(D, min_dist)
otus
propose_groups_of_cells(D, min_dist)
D
source("utils_DML.R")
source("utils_MFNJ.R")
# Input and initialization
cn_weight = 1e-3
alpha = .1
eps = .01
cells = sim$final_cells
cells_names = sim$cell_lifetimes %>% dplyr::filter(is_alive) %>% dplyr::pull(cell_id)
original_cells = cells_names = lapply(cells_names, function(c) {paste0("|",c,"|")}) %>% unlist()
N0 = length(cells)
# Initialize Cell matix C
C = bridges:::cells2countvectors(cells, L)
rownames(C) = cells_names
# Initalize distance matrix D
D = compute_distance_matrix(C, alpha = alpha, cn_weight = cn_weight)
colnames(D) = rownames(D) = rownames(C)
# Initialize Mask matrix M
M = matrix(data = FALSE, nrow = N0, ncol = N0)
diag(M) = TRUE
colnames(M) = rownames(M) = rownames(C)
# Initialize parent-daughters list
pd_list = list()
# Init iter and convergence flag
iter = 0
found_root = FALSE
while (!found_root) {
print(iter)
if ("new_cells" %in% rownames(C)) print(pippo)
# Iteration ####
# Mask Distance matrix
if (runif(1, 0, 1) < .2) {
D = compute_distance_matrix(C, alpha = alpha, cn_weight = cn_weight)
} else {
D = compute_distance_matrix(C, alpha = 0, cn_weight = cn_weight)
}
colnames(D) = rownames(D) = rownames(C)
D[M] = Inf
# Find smallest distance
new_cells_and_daughters = NULL
minimal_distances = unique(sort(D))
min_dist_idx = 0
while (is.null(new_cells_and_daughters)) {
min_dist_idx = min_dist_idx + 1
min_dist = minimal_distances[min_dist_idx]
otus = propose_groups_of_cells(D, min_dist)
new_cells_and_daughters = clean_group_of_cells(otus, C)
}
new_cells = new_cells_and_daughters$parents
daughters = new_cells_and_daughters$daughters
# Update parent-daugherts list pd_list
names(daughters) = rownames(new_cells)
pd_list = c(pd_list, daughters)
# Update distance matrix
D_new <- compute_distance_matrix_enhanced(new_cells, alpha = alpha, cn_weight = cn_weight)  # Distances within Y
D_old_new <- compute_distance_matrix_enhanced(C, new_cells, alpha = alpha, cn_weight = cn_weight)  # Distances between X and Y
D <- rbind(
cbind(D, D_old_new),
cbind(t(D_old_new), D_new)
)
# Update C
C = rbind(C, new_cells)
# Update M
M = extend_M(M = M, C = C)
# Update names
rownames(M) = colnames(M) = rownames(D) = colnames(D) = rownames(C)
# Update masking of M
M = update_M(M, daughters, pd_list)
# Check if we find root, i.e. pseudo cell with all original cells
is_root = function(cell_name, N0) {
cells_used = unlist(strsplit(gsub("\\|", "", cell_name), "-"))
if (length(cells_used) != length(unique(cells_used))) stop("something bad happened")
length(cells_used) == N0
}
found_root = any(unlist(lapply(rownames(new_cells), function(x) {is_root(x, N0)})))
iter = iter + 1
}
source("utils_DML.R")
source("utils_MFNJ.R")
# Input and initialization
cn_weight = 1e-3
alpha = .1
eps = .01
cells = sim$final_cells
cells_names = sim$cell_lifetimes %>% dplyr::filter(is_alive) %>% dplyr::pull(cell_id)
original_cells = cells_names = lapply(cells_names, function(c) {paste0("|",c,"|")}) %>% unlist()
N0 = length(cells)
# Initialize Cell matix C
C = bridges:::cells2countvectors(cells, L)
rownames(C) = cells_names
# Initalize distance matrix D
D = compute_distance_matrix(C, alpha = alpha, cn_weight = cn_weight)
colnames(D) = rownames(D) = rownames(C)
# Initialize Mask matrix M
M = matrix(data = FALSE, nrow = N0, ncol = N0)
diag(M) = TRUE
colnames(M) = rownames(M) = rownames(C)
# Initialize parent-daughters list
pd_list = list()
# Init iter and convergence flag
iter = 0
found_root = FALSE
while (!found_root) {
print(iter)
if ("new_cells" %in% rownames(C)) print(pippo)
# Iteration ####
# Mask Distance matrix
if (runif(1, 0, 1) < .2) {
D = compute_distance_matrix(C, alpha = alpha, cn_weight = .1)
} else {
D = compute_distance_matrix(C, alpha = alpha, cn_weight = cn_weight)
}
colnames(D) = rownames(D) = rownames(C)
D[M] = Inf
# Find smallest distance
new_cells_and_daughters = NULL
minimal_distances = unique(sort(D))
min_dist_idx = 0
while (is.null(new_cells_and_daughters)) {
min_dist_idx = min_dist_idx + 1
min_dist = minimal_distances[min_dist_idx]
otus = propose_groups_of_cells(D, min_dist)
new_cells_and_daughters = clean_group_of_cells(otus, C)
}
new_cells = new_cells_and_daughters$parents
daughters = new_cells_and_daughters$daughters
# Update parent-daugherts list pd_list
names(daughters) = rownames(new_cells)
pd_list = c(pd_list, daughters)
# Update distance matrix
D_new <- compute_distance_matrix_enhanced(new_cells, alpha = alpha, cn_weight = cn_weight)  # Distances within Y
D_old_new <- compute_distance_matrix_enhanced(C, new_cells, alpha = alpha, cn_weight = cn_weight)  # Distances between X and Y
D <- rbind(
cbind(D, D_old_new),
cbind(t(D_old_new), D_new)
)
# Update C
C = rbind(C, new_cells)
# Update M
M = extend_M(M = M, C = C)
# Update names
rownames(M) = colnames(M) = rownames(D) = colnames(D) = rownames(C)
# Update masking of M
M = update_M(M, daughters, pd_list)
# Check if we find root, i.e. pseudo cell with all original cells
is_root = function(cell_name, N0) {
cells_used = unlist(strsplit(gsub("\\|", "", cell_name), "-"))
if (length(cells_used) != length(unique(cells_used))) stop("something bad happened")
length(cells_used) == N0
}
found_root = any(unlist(lapply(rownames(new_cells), function(x) {is_root(x, N0)})))
iter = iter + 1
}
