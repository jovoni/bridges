# The idea is to find the most important breakpoints
# And propose a tree, in order to understand whether some
# which of the proposed outcomes best fit the data
rm(list = ls())
library(Rcpp)
library(data.tree)
require(tidyverse)
library(bridges)
#library(magick)
sourceCpp("cpp_utils.cpp")
sourceCpp("utils.cpp")
source("get_data.R")
source("utils.R")
source("../bfb/utils.R")
# Get the data from the get_data script
data = get_data(n_events = 1, bfb_rate = .05, seed = 1234)
x = data$x
bridges:::plot_heatmap(x, add_tree = TRUE, raster_quality = 3, tree_width = 5)
# Get most important breakpoints
top_N_bp = 100
min_f = .05
Ncells = length(x$cells)
breakpoints = (table(data$breakpoints$idxs) %>% sort(decreasing = T))[1:top_N_bp]
breakpoints = breakpoints[!is.na(breakpoints)]
breakpoints = breakpoints / Ncells
breakpoints = breakpoints[breakpoints >= min_f]
breakpoints = as.numeric(names(breakpoints))
breakpoints = sort(breakpoints)
names(breakpoints) = paste0("bp_", 1:length(breakpoints))
# Utils ####
count_unique_structures <- function(list_of_lists) {
# Extract the first element from each sub-list
first_elements <- lapply(list_of_lists, function(x) x[[1]])
# Initialize counter and list to store unique structures
unique_count <- 0
unique_structures <- list()
# Check each structure
for (struct in first_elements) {
is_unique <- TRUE
# Compare with already found unique structures
for (unique_struct in unique_structures) {
if (identical(struct, unique_struct)) {
is_unique <- FALSE
break
}
}
# If unique, add to the list
if (is_unique) {
unique_count <- unique_count + 1
unique_structures[[unique_count]] <- struct
}
}
return(unique_count)
}
get_best_k_proposals = function(proposals, K, use_smooth, iter = 100) {
all_results = lapply(1:iter, function(i) {
root_idx = sample(1:length(proposals), 1)
proposal = bridges:::propose_tree(proposals[[root_idx]]$tree, proposals[[root_idx]]$remaining_bps)
leaves = extract_all_nodes_with_names(proposal$tree)
if (use_smooth) {
X_input = smooth_X_cpp(X, breakpoints = breakpoints)
lambdas = lapply(leaves, function(l) {
matrix(l, nrow = 1)
}) %>% do.call("rbind", .)
rownames(lambdas) = names(leaves)
} else {
#leaves = bridges:::extract_leaf_vecs_with_names(root)
lambdas = bridges:::get_proposed_clusters(leaves, breakpoints)
X_input = X
}
results <- poisson_mixture_assignment_cpp(X_input + 1, lambdas + 1, return_responsibilities = FALSE)
results$lambdas = lambdas
results$use_smooth = use_smooth
distance = mean(abs(X_input - lambdas[results$assignments,,drop=FALSE]))
df_iter = dplyr::bind_rows(
dplyr::tibble(
iteration = i,
ll = results$log_likelihood,
distance = distance
)
)
list(proposal = proposal, df = df_iter %>% dplyr::mutate(tree_id = i))
})
merged_tibble <- all_results %>%
map(2) %>%  # Extract second element from each sublist
bind_rows()  # Combine all tibbles by rows
best_id = merged_tibble %>% dplyr::arrange(-ll)
best_k_ids = best_id$tree_id[1:K]
lapply(best_k_ids, function(k) {all_results[[k]]$proposal})
}
extract_all_nodes_with_names <- function(node) {
if (is.null(node)) return(NULL)
current_node <- stats::setNames(list(node$vec), node$seq)
if (is.null(node$left) && is.null(node$right)) {
return(current_node)
}
c(current_node,
extract_all_nodes_with_names(node$left),
extract_all_nodes_with_names(node$right))
}
# Iterative version ####
use_smooth = T
N <- length(breakpoints) + 1
root_seq <- paste0(LETTERS[1:N], collapse = "")
X = bridges:::cells2mat(x$cells, x$input_parameters$initial_sequence_length, order = F)
L = x$input_parameters$initial_sequence_length
all_results = parallel::mclapply(1:4000, function(tree_id) {
#print(tree_id)
root <- bridges:::init_cell(root_seq, N)
bps <- 1:length(breakpoints)
names(bps) <- sapply(1:length(bps), function(i) {
paste0(LETTERS[i:(i + 1)], collapse = "")
})
# Start iteration
df_iter = dplyr::tibble()
iter = 1
while(length(bps) > 0) {
proposal = bridges:::propose_tree(root, bps)
root = proposal$tree
bps = proposal$remaining_bps
iter = iter + 1
}
#plot(bridges:::convert_to_dataTree(root))
leaves = extract_all_nodes_with_names(root)
if (use_smooth) {
X_input = smooth_X_cpp(X, breakpoints = breakpoints)
lambdas = lapply(leaves, function(l) {
matrix(l, nrow = 1)
}) %>% do.call("rbind", .)
rownames(lambdas) = names(leaves)
} else {
#leaves = bridges:::extract_leaf_vecs_with_names(root)
lambdas = bridges:::get_proposed_clusters(leaves, breakpoints)
X_input = X
}
# unique_lambdas = apply(unique(lambdas), 1, function(l) {paste0(l,collapse = "")})
# unique_X = apply(unique(X_input), 1, function(l) {paste0(l,collapse = "")})
#
# if (all(unique_X %in% unique_lambdas)) {
#   print(tree_id)
# }
results <- poisson_mixture_assignment_cpp(X_input + 1, lambdas + 1, return_responsibilities = FALSE)
results$use_smooth = use_smooth
results$lambdas = lambdas
results$breakpoints = breakpoints
distance = mean(abs(X_input - lambdas[results$assignments,,drop=FALSE]))
results$tree = root
df_iter = dplyr::bind_rows(
dplyr::tibble(
iteration = iter,
ll = results$log_likelihood,
distance = distance
)
)
list(results = results, df = df_iter %>% dplyr::mutate(tree_id = tree_id))
}, mc.cores = 1)
library(purrr)
library(ggplot2)
# Assuming your list is called 'list_of_lists'
merged_tibble <- all_results %>%
map(2) %>%  # Extract second element from each sublist
bind_rows()  # Combine all tibbles by rows
merged_tibble %>%
ggplot(mapping = aes(x=ll)) +
geom_histogram() +
theme(legend.position = "none") +
labs(x = "Log-likelihood", y = "Count") +
theme_classic()
merged_tibble %>%
ggplot(mapping = aes(x=distance)) +
geom_histogram() +
theme(legend.position = "none") +
labs(x = "distance", y = "Count") +
theme_classic()
merged_tibble %>%
ggplot(mapping = aes(x=distance, y=ll)) +
geom_point()
best_id = (merged_tibble %>%
dplyr::filter(iteration == max(iteration)) %>%
dplyr::filter(ll == max(ll)) %>%
dplyr::pull(tree_id))[1]
best_res = all_results[[best_id]]$results
print(plot_mat(X, add_gain_loss_profile = T))
print(plot(bridges:::convert_to_dataTree(best_tree)))
print(plot(bridges:::convert_to_dataTree(best_res$tree)))
print(ggplot2::ggplot(get_breakpoints(X), mapping = aes(x=idxs)) +
geom_histogram(binwidth = 1) +
scale_x_continuous(limits = c(0,100)) +
theme_bw() +
ggtitle("Breakpoints distribution"))
print(bridges:::plot_heatmap(x, use_raster = F, add_tree = TRUE, full_tree = F, tree_width = 3))
print(plot_clustering(X, results = best_res, reconstruct_X = F))
plot_clustering = function(x, result, reconstruct_X, tree_width=5, use_raster=FALSE, raster_quality=3) {
# Retrieve results for best tree
lambdas = result$lambdas
if (is.list(x)) {
X = cells2mat(x$cells, x$input_parameters$initial_sequence_length, order = F)
} else {
X = x
}
leaves_assignment = rownames(lambdas)[result$assignments]
if (reconstruct_X) {
leaves = extract_all_nodes_with_names(result$tree)
L = ncol(X)
lambdas = bridges:::get_proposed_clusters(leaves, result$breakpoints)
X_rownames = rownames(X)
X = lambdas[result$assignments,,drop=FALSE]
rownames(X) = X_rownames
}
tree_df = bridges:::build_phylogeny_df(result$tree)
tree_df = tree_df %>%
dplyr::rename(cell_id = seq_name, parent_id = parent_seq) %>%
dplyr::bind_rows(dplyr::tibble(cell_id = rownames(X), parent_id = leaves_assignment)) %>%
dplyr::mutate(birth_time = NA, bfb_event = F, hotspot_gained = F)
tree_data = bridges:::get_tree_data(list(cell_history = tree_df), branch_lengths = F, full_tree = TRUE)
tree_ggplot = bridges:::plot_tree(tree_data, annotate_tip = F)
ordered_cell_ids <- bridges:::get_ordered_cell_ids(tree_ggplot$data)
make_corrupt_tree_heatmap_v2 <- function(tree_ggplot, tree_width, ...) {
tree_annot_func <- ComplexHeatmap::AnnotationFunction(
fun = function(index) {
pushViewport(viewport(height = 1))
grid.draw(ggplot2::ggplotGrob(tree_ggplot)$grobs[[6]])
popViewport()
},
var_import = list(tree_ggplot = tree_ggplot),
width = grid::unit(tree_width, "cm"),
which = "row"
)
tree_annot <- ComplexHeatmap::HeatmapAnnotation(
tree = tree_annot_func, which = "row", show_annotation_name = FALSE
)
n_cells <- sum(tree_ggplot$data$isTip)
tree_hm <- ComplexHeatmap::Heatmap(matrix(ncol = 0, nrow = n_cells), left_annotation = tree_annot, ...)
return(tree_hm)
}
tree_hm = make_corrupt_tree_heatmap_v2(tree_ggplot, tree_width = tree_width)
clusters = matrix(leaves_assignment, ncol = 1)
rownames(clusters) = rownames(X)
high_cn_mask = X > 10
mat_row_names = rownames(X)
X = matrix(as.character(X), ncol = ncol(X), nrow = nrow(X))
X[high_cn_mask] = "11+"
X = data.frame(X)
rownames(X) = mat_row_names
colvals <- bridges:::get_colors("CN")
X = X[ordered_cell_ids, , drop = FALSE]
not_observed_clsuters = ordered_cell_ids[!ordered_cell_ids %in% rownames(clusters)]
if (length(not_observed_clsuters)) {
not_observed_clsuters = matrix(NA, nrow = length(not_observed_clsuters), dimnames = list(not_observed_clsuters, NULL))
clusters = rbind(clusters, not_observed_clsuters)
}
clusters = clusters[ordered_cell_ids, , drop=FALSE]
make_clone_palette <- function(levels) {
levels <- as.character(levels)  # Ensure levels are characters
# Assign colors based on the number of levels
if (length(levels) <= 8) {
pal <- RColorBrewer::brewer.pal(max(length(levels), 3), "Paired")
} else {
pal <- grDevices::colorRampPalette(RColorBrewer::brewer.pal(max(length(levels), 3), "Paired"))(length(levels))
}
# Ensure names are correctly assigned
names(pal) <- levels
pal <- pal[levels]
# Assign a default color for NA values
if (any(is.na(levels))) {
pal[is.na(names(pal))] <- "grey"  # Assign grey color for NA clusters
names(pal)[is.na(names(pal))] <- "NA"
}
return(pal)
}
# Define annotation colors correctly
col_anno = make_clone_palette(unique(clusters))
# Ensure NA clusters are mapped correctly
if ("NA" %in% names(col_anno)) {
col_anno["NA"] <- "grey"  # Explicitly set the NA color
}
# Create annotation
cluster_annotation = ComplexHeatmap::rowAnnotation(
Cluster = clusters,
col = list(Cluster = col_anno)  # Ensure col is a named list of vectors
)
# Heatmap
copynumber_hm = ComplexHeatmap::Heatmap(
name = "Copy Number",
as.matrix(X),
col = colvals,
show_column_names = FALSE,
show_row_names = FALSE,
use_raster = use_raster,
raster_quality = raster_quality,
cluster_rows = FALSE,
cluster_columns = FALSE,
left_annotation = cluster_annotation
)
# Combine heatmaps
p = tree_hm + copynumber_hm
p
}
print(plot_clustering(X, results = best_res, reconstruct_X = F))
plot_clustering(X, results = best_res, reconstruct_X = F)
print(plot_clustering(X, result = best_res, reconstruct_X = F))
# The idea is to find the most important breakpoints
# And propose a tree, in order to understand whether some
# which of the proposed outcomes best fit the data
rm(list = ls())
library(Rcpp)
library(data.tree)
require(tidyverse)
library(bridges)
#library(magick)
sourceCpp("cpp_utils.cpp")
sourceCpp("utils.cpp")
source("get_data.R")
source("utils.R")
source("../bfb/utils.R")
# Get the data from the get_data script
data = get_data(n_events = 1, bfb_rate = .05, seed = 1234)
x = data$x
bridges:::plot_heatmap(x, add_tree = TRUE, raster_quality = 3, tree_width = 5)
# Get most important breakpoints
top_N_bp = 100
min_f = .05
Ncells = length(x$cells)
breakpoints = (table(data$breakpoints$idxs) %>% sort(decreasing = T))[1:top_N_bp]
breakpoints = breakpoints[!is.na(breakpoints)]
breakpoints = breakpoints / Ncells
breakpoints
breakpoints = (table(data$breakpoints$idxs) %>% sort(decreasing = T))[1:top_N_bp]
breakpoints
12 / Ncells
7 / Ncells
min_f = .04
Ncells = length(x$cells)
breakpoints = (table(data$breakpoints$idxs) %>% sort(decreasing = T))[1:top_N_bp]
breakpoints = breakpoints[!is.na(breakpoints)]
breakpoints = breakpoints / Ncells
breakpoints = breakpoints[breakpoints >= min_f]
breakpoints = as.numeric(names(breakpoints))
breakpoints = sort(breakpoints)
names(breakpoints) = paste0("bp_", 1:length(breakpoints))
# Utils ####
count_unique_structures <- function(list_of_lists) {
# Extract the first element from each sub-list
first_elements <- lapply(list_of_lists, function(x) x[[1]])
# Initialize counter and list to store unique structures
unique_count <- 0
unique_structures <- list()
# Check each structure
for (struct in first_elements) {
is_unique <- TRUE
# Compare with already found unique structures
for (unique_struct in unique_structures) {
if (identical(struct, unique_struct)) {
is_unique <- FALSE
break
}
}
# If unique, add to the list
if (is_unique) {
unique_count <- unique_count + 1
unique_structures[[unique_count]] <- struct
}
}
return(unique_count)
}
get_best_k_proposals = function(proposals, K, use_smooth, iter = 100) {
all_results = lapply(1:iter, function(i) {
root_idx = sample(1:length(proposals), 1)
proposal = bridges:::propose_tree(proposals[[root_idx]]$tree, proposals[[root_idx]]$remaining_bps)
leaves = extract_all_nodes_with_names(proposal$tree)
if (use_smooth) {
X_input = smooth_X_cpp(X, breakpoints = breakpoints)
lambdas = lapply(leaves, function(l) {
matrix(l, nrow = 1)
}) %>% do.call("rbind", .)
rownames(lambdas) = names(leaves)
} else {
#leaves = bridges:::extract_leaf_vecs_with_names(root)
lambdas = bridges:::get_proposed_clusters(leaves, breakpoints)
X_input = X
}
results <- poisson_mixture_assignment_cpp(X_input + 1, lambdas + 1, return_responsibilities = FALSE)
results$lambdas = lambdas
results$use_smooth = use_smooth
distance = mean(abs(X_input - lambdas[results$assignments,,drop=FALSE]))
df_iter = dplyr::bind_rows(
dplyr::tibble(
iteration = i,
ll = results$log_likelihood,
distance = distance
)
)
list(proposal = proposal, df = df_iter %>% dplyr::mutate(tree_id = i))
})
merged_tibble <- all_results %>%
map(2) %>%  # Extract second element from each sublist
bind_rows()  # Combine all tibbles by rows
best_id = merged_tibble %>% dplyr::arrange(-ll)
best_k_ids = best_id$tree_id[1:K]
lapply(best_k_ids, function(k) {all_results[[k]]$proposal})
}
extract_all_nodes_with_names <- function(node) {
if (is.null(node)) return(NULL)
current_node <- stats::setNames(list(node$vec), node$seq)
if (is.null(node$left) && is.null(node$right)) {
return(current_node)
}
c(current_node,
extract_all_nodes_with_names(node$left),
extract_all_nodes_with_names(node$right))
}
# Iterative version ####
use_smooth = T
N <- length(breakpoints) + 1
root_seq <- paste0(LETTERS[1:N], collapse = "")
X = bridges:::cells2mat(x$cells, x$input_parameters$initial_sequence_length, order = F)
L = x$input_parameters$initial_sequence_length
all_results = parallel::mclapply(1:4000, function(tree_id) {
#print(tree_id)
root <- bridges:::init_cell(root_seq, N)
bps <- 1:length(breakpoints)
names(bps) <- sapply(1:length(bps), function(i) {
paste0(LETTERS[i:(i + 1)], collapse = "")
})
# Start iteration
df_iter = dplyr::tibble()
iter = 1
while(length(bps) > 0) {
proposal = bridges:::propose_tree(root, bps)
root = proposal$tree
bps = proposal$remaining_bps
iter = iter + 1
}
#plot(bridges:::convert_to_dataTree(root))
leaves = extract_all_nodes_with_names(root)
if (use_smooth) {
X_input = smooth_X_cpp(X, breakpoints = breakpoints)
lambdas = lapply(leaves, function(l) {
matrix(l, nrow = 1)
}) %>% do.call("rbind", .)
rownames(lambdas) = names(leaves)
} else {
#leaves = bridges:::extract_leaf_vecs_with_names(root)
lambdas = bridges:::get_proposed_clusters(leaves, breakpoints)
X_input = X
}
# unique_lambdas = apply(unique(lambdas), 1, function(l) {paste0(l,collapse = "")})
# unique_X = apply(unique(X_input), 1, function(l) {paste0(l,collapse = "")})
#
# if (all(unique_X %in% unique_lambdas)) {
#   print(tree_id)
# }
results <- poisson_mixture_assignment_cpp(X_input + 1, lambdas + 1, return_responsibilities = FALSE)
results$use_smooth = use_smooth
results$lambdas = lambdas
results$breakpoints = breakpoints
distance = mean(abs(X_input - lambdas[results$assignments,,drop=FALSE]))
results$tree = root
df_iter = dplyr::bind_rows(
dplyr::tibble(
iteration = iter,
ll = results$log_likelihood,
distance = distance
)
)
list(results = results, df = df_iter %>% dplyr::mutate(tree_id = tree_id))
}, mc.cores = 1)
# Greedy Version ####
use_smooth = T
N <- length(breakpoints) + 1
root_seq <- paste0(LETTERS[1:N], collapse = "")
X = bridges:::cells2mat(x$cells, x$input_parameters$initial_sequence_length, order = F)
library(purrr)
library(ggplot2)
# Assuming your list is called 'list_of_lists'
merged_tibble <- all_results %>%
map(2) %>%  # Extract second element from each sublist
bind_rows()  # Combine all tibbles by rows
merged_tibble %>%
ggplot(mapping = aes(x=ll)) +
geom_histogram() +
theme(legend.position = "none") +
labs(x = "Log-likelihood", y = "Count") +
theme_classic()
merged_tibble %>%
ggplot(mapping = aes(x=distance)) +
geom_histogram() +
theme(legend.position = "none") +
labs(x = "distance", y = "Count") +
theme_classic()
merged_tibble %>%
ggplot(mapping = aes(x=distance, y=ll)) +
geom_point()
best_id = (merged_tibble %>%
dplyr::filter(iteration == max(iteration)) %>%
dplyr::filter(ll == max(ll)) %>%
dplyr::pull(tree_id))[1]
best_res = all_results[[best_id]]$results
png("plot/report.pdf", width = 8, height = 6, units = "in", res = 400)
print(plot_mat(X, add_gain_loss_profile = T))
print(plot_mat(X, add_gain_loss_profile = T))
dev.off()
#png("plot/report.pdf", width = 8, height = 6, units = "in", res = 400)
print(plot_mat(X, add_gain_loss_profile = T))
print(plot(bridges:::convert_to_dataTree(best_res$tree)))
print(ggplot2::ggplot(get_breakpoints(X), mapping = aes(x=idxs)) +
geom_histogram(binwidth = 1) +
scale_x_continuous(limits = c(0,100)) +
theme_bw() +
ggtitle("Breakpoints distribution"))
print(bridges:::plot_heatmap(x, use_raster = F, add_tree = TRUE, full_tree = F, tree_width = 3))
print(plot_clustering(X, result = best_res, reconstruct_X = F))
