# Extract the Newick tree string
plot_heatmap_CN_profiles(sim$final_cells, L, order = F)
rm(list = ls())
gillespie_sim_with_newick <- function(
initial_cells = 1,
initial_sequence_length = 100,
birth_rate = 0.1,
death_rate = 0.001,
bfb_prob = 0.01,
max_time = 50,
max_cells = 100,
first_n_bfb_cycles = 0,
first_round_of_bfb = TRUE,
breakpoint_support = "uniform",
alpha = NULL,
beta = NULL
) {
# Initialize
time <- 0
cells <- list()
birth_count <- 0  # Track number of birth events
death_count <- 0
# Track cell creation times, IDs, parents, whether they resulted from BFB, and last event time
cell_ids <- integer(0)
cell_birth_times <- numeric(0)
cell_death_times <- numeric(0)
cell_parents <- integer(0)  # Track parent of each cell
cell_bfb <- logical(0)  # Track whether the cell resulted from a BFB event
cell_last_event <- numeric(0)  # Track the last time each cell underwent an event
next_cell_id <- 1
# Create the initial cell with its sequence
initial_sequence <- vec2seq(1:initial_sequence_length)
# Apply BFB to all initial cells if first_round_of_bfb is TRUE
if (first_round_of_bfb) {
# Create temporary storage for new cells after BFB
new_cells <- list()
new_cell_ids <- integer(0)
new_birth_times <- numeric(0)
new_death_times <- numeric(0)
new_parents <- integer(0)
new_bfb <- logical(0)
new_last_event <- numeric(0)
for (i in 1:initial_cells) {
# Apply BFB to create daughter sequences
daughter_seqs <- sim_bfb_left_and_right_sequences(initial_sequence, breakpoint_support, alpha, beta)
# Error checking
if (any(is.na(daughter_seqs$l_seq))) {
stop("NA values in left daughter sequence")
}
if (any(is.na(daughter_seqs$r_seq))) {
stop("NA values in right daughter sequence")
}
# Add both daughters to new cells list
new_cells[[length(new_cells) + 1]] <- daughter_seqs$l_seq
new_cells[[length(new_cells) + 1]] <- daughter_seqs$r_seq
# Record cell creation data for both new cells
new_cell_ids <- c(new_cell_ids, next_cell_id, next_cell_id + 1)
new_birth_times <- c(new_birth_times, time, time)
new_death_times <- c(new_death_times, NA, NA)  # Not dead yet
new_parents <- c(new_parents, 0, 0)  # Initial cells have no parent
new_bfb <- c(new_bfb, TRUE, TRUE)  # Both daughters resulted from BFB
new_last_event <- c(new_last_event, time, time)  # Set last event time to current time
next_cell_id <- next_cell_id + 2
}
# Replace the original cells with new BFB-processed cells
cells <- new_cells
cell_ids <- new_cell_ids
cell_birth_times <- new_birth_times
cell_death_times <- new_death_times
cell_parents <- new_parents
cell_bfb <- new_bfb
cell_last_event <- new_last_event
} else {
# Original initialization without BFB
for (i in 1:initial_cells) {
cells[[i]] <- initial_sequence
# Record cell creation data
cell_ids <- c(cell_ids, next_cell_id)
cell_birth_times <- c(cell_birth_times, time)
cell_death_times <- c(cell_death_times, NA)  # Not dead yet
cell_parents <- c(cell_parents, 0)  # Initial cells have no parent
cell_bfb <- c(cell_bfb, FALSE)  # Initial cells did not result from BFB
cell_last_event <- c(cell_last_event, time)  # Set last event time to current time
next_cell_id <- next_cell_id + 1
}
}
# Main simulation loop
while (time < max_time && length(cells) > 0 && length(cells) < max_cells) {
# Calculate propensities
total_birth_prop <- birth_rate * length(cells)
total_death_prop <- death_rate * length(cells)
total_prop <- total_birth_prop + total_death_prop
# If all cells died or total propensity is 0, exit
if (length(cells) == 0 || total_prop == 0) {
break
}
# Time until next event
dt <- stats::rexp(1, total_prop)
time <- time + dt
# Determine event type
if (stats::runif(1) < total_birth_prop / total_prop) {
# Birth event
birth_count <- birth_count + 1
# Select parent cell based on time since last event
time_since_last_event <- time - cell_last_event
selection_probs <- time_since_last_event / sum(time_since_last_event)
parent_idx <- sample(1:length(cells), 1, prob = selection_probs)
parent_seq <- cells[[parent_idx]]
parent_id <- cell_ids[parent_idx]
# Update last event time for the parent cell
cell_last_event[parent_idx] <- time
# Determine if BFB should occur
force_bfb <- birth_count <= first_n_bfb_cycles
random_bfb <- stats::runif(1) < bfb_prob
if (force_bfb || random_bfb) {
# Apply the mutation function to get two daughter sequences
daughter_seqs <- sim_bfb_left_and_right_sequences(parent_seq, breakpoint_support, alpha, beta)
if (any(is.na(daughter_seqs$l_seq))) {
stop("NA values in left daughter sequence")
}
if (any(is.na(daughter_seqs$r_seq))) {
stop("NA values in right daughter sequence")
}
# Replace parent with left daughter
cells[[parent_idx]] <- daughter_seqs$l_seq
# Add right daughter as new cell
cells[[length(cells) + 1]] <- daughter_seqs$r_seq
# Record cell creation data for the new cell
cell_ids <- c(cell_ids, next_cell_id)
cell_birth_times <- c(cell_birth_times, time)
cell_death_times <- c(cell_death_times, NA)  # Not dead yet
cell_parents <- c(cell_parents, parent_id)  # Record parent
cell_bfb <- c(cell_bfb, TRUE)  # New cell resulted from BFB
cell_last_event <- c(cell_last_event, time)  # Set last event time for new cell
next_cell_id <- next_cell_id + 1
} else {
# Normal replication without mutation
# Parent cell remains unchanged
# Add identical daughter cell
cells[[length(cells) + 1]] <- parent_seq
# Record cell creation data for the new cell
cell_ids <- c(cell_ids, next_cell_id)
cell_birth_times <- c(cell_birth_times, time)
cell_death_times <- c(cell_death_times, NA)  # Not dead yet
cell_parents <- c(cell_parents, parent_id)  # Record parent
cell_bfb <- c(cell_bfb, FALSE)  # New cell did not result from BFB
cell_last_event <- c(cell_last_event, time)  # Set last event time for new cell
next_cell_id <- next_cell_id + 1
}
} else {
# Death event - remove a random cell
death_count <- death_count + 1
if (length(cells) > 0) {
# Select cell to remove based on time since last event
time_since_last_event <- time - cell_last_event
selection_probs <- time_since_last_event / sum(time_since_last_event)
cell_to_remove <- sample(1:length(cells), 1, prob = selection_probs)
# Record death time
cell_death_times[cell_to_remove] <- time
# Remove the cell from the list of alive cells
cells <- cells[-cell_to_remove]
cell_last_event <- cell_last_event[-cell_to_remove]
}
}
}
# Create cell lifetime data
cell_death_times[is.na(cell_death_times)] <- time
cell_lifetimes <- data.frame(
cell_id = cell_ids,
birth_time = cell_birth_times,
death_time = cell_death_times,
lifetime = cell_death_times - cell_birth_times,
is_alive = cell_death_times == max(cell_death_times),
parent_id = cell_parents,
bfb_event = cell_bfb
)
# Function to recursively build Newick string
build_newick <- function(node_id) {
children <- cell_lifetimes$cell_id[cell_lifetimes$parent_id == node_id & cell_lifetimes$bfb_event]
if (length(children) == 0) {
return(as.character(node_id))
} else {
child_newick <- sapply(children, build_newick)
return(paste0("(", paste(child_newick, collapse = ","), ")", node_id))
}
}
# Build the Newick tree starting from the root (parent_id = 0)
newick_tree <- build_newick(0)
# Return results including the Newick tree
return(list(
final_cells = cells,
sequence_distribution = table(sapply(cells, function(seq) paste(unlist(seq), collapse = ","))),
cell_lifetimes = cell_lifetimes,
final_time = time,
birth_count = birth_count,
death_count = death_count,
newick_tree = newick_tree  # Include the Newick tree
))
}
L = 100
sim = gillespie_sim_with_newick(initial_cells = 1, death_rate = 0, max_cells = 100, bfb_prob = .0, initial_sequence_length = L)
# Extract the Newick tree string
plot_heatmap_CN_profiles(sim$final_cells, L, order = F)
newick_tree <- sim$newick_tree
sim$cell_lifetimes
# Parse the Newick string into a phylo object
if (!grepl(";$", newick_tree)) {
newick_tree <- paste0(newick_tree, ";")
}
# Parse the Newick string into a phylo object
tree <- ape::read.tree(text = newick_tree)
# Plot the tree using ggtree
ggtree::ggtree(tree) +
ggtree::geom_tiplab()
# Compute distances
countvectors = cells2countvectors(sim$final_cells, 100)
n = length(sim$final_cells)
image(t(countvectors))
vectors = countvectors
alpha = 1/2
custom_distance <- function(v1, v2, alpha) {
diff = abs(v1 - v2)
diff[diff == 2] = alpha
sqrt(sum((diff)^2))
}
# Step 2: Compute the distance matrix
dist_matrix <- matrix(0, nrow = n, ncol = n)
for (i in 1:n) {
for (j in 1:n) {
dist_matrix[i, j] <- custom_distance(vectors[i, ], vectors[j, ], alpha)
}
}
print(dist_matrix)
image(t(dist_matrix))
# Step 3: Perform hierarchical clustering
hclust_result <- hclust(as.dist(dist_matrix), method = "complete")  # Use "complete" linkage
# Step 4: Plot the dendrogram
plot(hclust_result, main = "Dendrogram with Custom Distance", xlab = "", sub = "")
sim$cell_lifetimes
install.packages("devtools")
install.packages("pkgdwon")
install.packages("pkgdown")
install.packages("devtools")
install.packages("devtools")
install.packages("ragg")
install.packages("ragg")
install.packages("pkgdown")
install.packages("pkgdown")
install.packages("pkgdown")
install.packages("devtools")
install.packages("ragg")
install.packages("ragg")
install.packages("dplyr")
install.packages("ragg", "https://cran.r-project.org/src/contrib/ragg_1.3.3.tar.gz")
install.packages("tidyverse")
install.packages("ragg")
install.packages("ragg")
install.packages("devtools")
setwd("~/Github/bridges")
devtools::document()
devtools::document()
devtools::load_all()
rm(list = ls())
rm(list = ls())
gillespie_sim_with_newick <- function(
initial_cells = 1,
initial_sequence_length = 100,
birth_rate = 0.1,
death_rate = 0.001,
bfb_prob = 0.01,
max_time = 50,
max_cells = 100,
first_n_bfb_cycles = 0,
first_round_of_bfb = TRUE,
breakpoint_support = "uniform",
alpha = NULL,
beta = NULL
) {
# Initialize
time <- 0
cells <- list()
birth_count <- 0  # Track number of birth events
death_count <- 0
# Track cell creation times, IDs, parents, whether they resulted from BFB, and last event time
cell_ids <- integer(0)
cell_birth_times <- numeric(0)
cell_death_times <- numeric(0)
cell_parents <- integer(0)  # Track parent of each cell
cell_bfb <- logical(0)  # Track whether the cell resulted from a BFB event
cell_last_event <- numeric(0)  # Track the last time each cell underwent an event
next_cell_id <- 1
# Create the initial cell with its sequence
initial_sequence <- vec2seq(1:initial_sequence_length)
# Apply BFB to all initial cells if first_round_of_bfb is TRUE
if (first_round_of_bfb) {
# Create temporary storage for new cells after BFB
new_cells <- list()
new_cell_ids <- integer(0)
new_birth_times <- numeric(0)
new_death_times <- numeric(0)
new_parents <- integer(0)
new_bfb <- logical(0)
new_last_event <- numeric(0)
for (i in 1:initial_cells) {
# Apply BFB to create daughter sequences
daughter_seqs <- sim_bfb_left_and_right_sequences(initial_sequence, breakpoint_support, alpha, beta)
# Error checking
if (any(is.na(daughter_seqs$l_seq))) {
stop("NA values in left daughter sequence")
}
if (any(is.na(daughter_seqs$r_seq))) {
stop("NA values in right daughter sequence")
}
# Add both daughters to new cells list
new_cells[[length(new_cells) + 1]] <- daughter_seqs$l_seq
new_cells[[length(new_cells) + 1]] <- daughter_seqs$r_seq
# Record cell creation data for both new cells
new_cell_ids <- c(new_cell_ids, next_cell_id, next_cell_id + 1)
new_birth_times <- c(new_birth_times, time, time)
new_death_times <- c(new_death_times, NA, NA)  # Not dead yet
new_parents <- c(new_parents, 0, 0)  # Initial cells have no parent
new_bfb <- c(new_bfb, TRUE, TRUE)  # Both daughters resulted from BFB
new_last_event <- c(new_last_event, time, time)  # Set last event time to current time
next_cell_id <- next_cell_id + 2
}
# Replace the original cells with new BFB-processed cells
cells <- new_cells
cell_ids <- new_cell_ids
cell_birth_times <- new_birth_times
cell_death_times <- new_death_times
cell_parents <- new_parents
cell_bfb <- new_bfb
cell_last_event <- new_last_event
} else {
# Original initialization without BFB
for (i in 1:initial_cells) {
cells[[i]] <- initial_sequence
# Record cell creation data
cell_ids <- c(cell_ids, next_cell_id)
cell_birth_times <- c(cell_birth_times, time)
cell_death_times <- c(cell_death_times, NA)  # Not dead yet
cell_parents <- c(cell_parents, 0)  # Initial cells have no parent
cell_bfb <- c(cell_bfb, FALSE)  # Initial cells did not result from BFB
cell_last_event <- c(cell_last_event, time)  # Set last event time to current time
next_cell_id <- next_cell_id + 1
}
}
# Main simulation loop
while (time < max_time && length(cells) > 0 && length(cells) < max_cells) {
# Calculate propensities
total_birth_prop <- birth_rate * length(cells)
total_death_prop <- death_rate * length(cells)
total_prop <- total_birth_prop + total_death_prop
# If all cells died or total propensity is 0, exit
if (length(cells) == 0 || total_prop == 0) {
break
}
# Time until next event
dt <- stats::rexp(1, total_prop)
time <- time + dt
# Determine event type
if (stats::runif(1) < total_birth_prop / total_prop) {
# Birth event
birth_count <- birth_count + 1
# Select parent cell based on time since last event
time_since_last_event <- time - cell_last_event
selection_probs <- time_since_last_event / sum(time_since_last_event)
parent_idx <- sample(1:length(cells), 1, prob = selection_probs)
parent_seq <- cells[[parent_idx]]
parent_id <- cell_ids[parent_idx]
# Update last event time for the parent cell
cell_last_event[parent_idx] <- time
# Determine if BFB should occur
force_bfb <- birth_count <= first_n_bfb_cycles
random_bfb <- stats::runif(1) < bfb_prob
if (force_bfb || random_bfb) {
# Apply the mutation function to get two daughter sequences
daughter_seqs <- sim_bfb_left_and_right_sequences(parent_seq, breakpoint_support, alpha, beta)
if (any(is.na(daughter_seqs$l_seq))) {
stop("NA values in left daughter sequence")
}
if (any(is.na(daughter_seqs$r_seq))) {
stop("NA values in right daughter sequence")
}
# Replace parent with left daughter
cells[[parent_idx]] <- daughter_seqs$l_seq
# Add right daughter as new cell
cells[[length(cells) + 1]] <- daughter_seqs$r_seq
# Record cell creation data for the new cell
cell_ids <- c(cell_ids, next_cell_id)
cell_birth_times <- c(cell_birth_times, time)
cell_death_times <- c(cell_death_times, NA)  # Not dead yet
cell_parents <- c(cell_parents, parent_id)  # Record parent
cell_bfb <- c(cell_bfb, TRUE)  # New cell resulted from BFB
cell_last_event <- c(cell_last_event, time)  # Set last event time for new cell
next_cell_id <- next_cell_id + 1
} else {
# Normal replication without mutation
# Parent cell remains unchanged
# Add identical daughter cell
cells[[length(cells) + 1]] <- parent_seq
# Record cell creation data for the new cell
cell_ids <- c(cell_ids, next_cell_id)
cell_birth_times <- c(cell_birth_times, time)
cell_death_times <- c(cell_death_times, NA)  # Not dead yet
cell_parents <- c(cell_parents, parent_id)  # Record parent
cell_bfb <- c(cell_bfb, FALSE)  # New cell did not result from BFB
cell_last_event <- c(cell_last_event, time)  # Set last event time for new cell
next_cell_id <- next_cell_id + 1
}
} else {
# Death event - remove a random cell
death_count <- death_count + 1
if (length(cells) > 0) {
# Select cell to remove based on time since last event
time_since_last_event <- time - cell_last_event
selection_probs <- time_since_last_event / sum(time_since_last_event)
cell_to_remove <- sample(1:length(cells), 1, prob = selection_probs)
# Record death time
cell_death_times[cell_to_remove] <- time
# Remove the cell from the list of alive cells
cells <- cells[-cell_to_remove]
cell_last_event <- cell_last_event[-cell_to_remove]
}
}
}
# Create cell lifetime data
cell_death_times[is.na(cell_death_times)] <- time
cell_lifetimes <- data.frame(
cell_id = cell_ids,
birth_time = cell_birth_times,
death_time = cell_death_times,
lifetime = cell_death_times - cell_birth_times,
is_alive = cell_death_times == max(cell_death_times),
parent_id = cell_parents,
bfb_event = cell_bfb
)
# Function to recursively build Newick string
build_newick <- function(node_id) {
children <- cell_lifetimes$cell_id[cell_lifetimes$parent_id == node_id & cell_lifetimes$bfb_event]
if (length(children) == 0) {
return(as.character(node_id))
} else {
child_newick <- sapply(children, build_newick)
return(paste0("(", paste(child_newick, collapse = ","), ")", node_id))
}
}
# Build the Newick tree starting from the root (parent_id = 0)
newick_tree <- build_newick(0)
# Return results including the Newick tree
return(list(
final_cells = cells,
sequence_distribution = table(sapply(cells, function(seq) paste(unlist(seq), collapse = ","))),
cell_lifetimes = cell_lifetimes,
final_time = time,
birth_count = birth_count,
death_count = death_count,
newick_tree = newick_tree  # Include the Newick tree
))
}
L = 100
sim = gillespie_sim_with_newick(initial_cells = 1, death_rate = 0, max_cells = 100, bfb_prob = .0, initial_sequence_length = L)
plot_heatmap_CN_profiles(sim$final_cells, L, order = F)
newick_tree <- sim$newick_tree
sim$cell_lifetimes
# Parse the Newick string into a phylo object
if (!grepl(";$", newick_tree)) {
newick_tree <- paste0(newick_tree, ";")
}
# Parse the Newick string into a phylo object
tree <- ape::read.tree(text = newick_tree)
# Plot the tree using ggtree
ggtree::ggtree(tree) +
ggtree::geom_tiplab()
install.packages("BiocManager")
BiocManager::install("ggtree")
# Plot the tree using ggtree
ggtree::ggtree(tree) +
ggtree::geom_tiplab()
# Compute distances
countvectors = cells2countvectors(sim$final_cells, 100)
n = length(sim$final_cells)
image(t(countvectors))
vectors = countvectors
alpha = 1/2
custom_distance <- function(v1, v2, alpha) {
diff = abs(v1 - v2)
diff[diff == 2] = alpha
sqrt(sum((diff)^2))
}
# Step 2: Compute the distance matrix
dist_matrix <- matrix(0, nrow = n, ncol = n)
for (i in 1:n) {
for (j in 1:n) {
dist_matrix[i, j] <- custom_distance(vectors[i, ], vectors[j, ], alpha)
}
}
print(dist_matrix)
image(t(dist_matrix))
# Step 3: Perform hierarchical clustering
hclust_result <- hclust(as.dist(dist_matrix), method = "complete")  # Use "complete" linkage
# Step 4: Plot the dendrogram
plot(hclust_result, main = "Dendrogram with Custom Distance", xlab = "", sub = "")
sim$cell_lifetimes
oceanic_theme <- fs::path_temp("Oceanic-Eighties", ext = "rstheme")
download.file("https://git.io/rstudio-theme-oceanic-eighties", oceanic_theme)
rstudioapi::addTheme(oceanic_theme, apply = TRUE)
pwd
getwd()
rm(list = ls())
devtools::document()
devtools::load_all()
